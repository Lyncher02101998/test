import telebot
from telebot import types
import mysql.connector
from datetime import datetime
from datetime import date

mysql_host = 'localhost'
mysql_user = 'user'
mysql_password = ''
mysql_database = 'teldb'
# Соединение с MySQL
conn = mysql.connector.connect(host=mysql_host, user=mysql_user, password=mysql_password, database=mysql_database)

bot = telebot.TeleBot('6376709843:AAFbZ6GrQqrFWCQZml1A7t-Y-SLwHarFhl0')

# Создайте словарь для отслеживания идентификаторов чатов и соответствующих им запросов
user_requests = {}

# Отправляем ответ по команде "start"
@bot.message_handler(commands=['start'])

def start_message(message):
    bot.send_message(message.chat.id,
                     f'Здравствуйте {message.from_user.first_name}, введите ID Банкомата\Терминала, для получения статуса или отправки заявки')

# Отправляем ответ по команде "ID Terminal"
@bot.message_handler(content_types=['text'])
def info(message):
    global mess

    # Проверка ID в базе
    mess = message.text
    cur = conn.cursor()

    cur.execute('SELECT ID FROM terminal WHERE ID = "' + message.text + '"')
    id = cur.fetchone()


    # Проверка ID в таблице zabbix
    if id is not None:
        # Проверяем, существует ли уже запись с таким же terminal_id и сегодняшней датой
        today_date = date.today().strftime('%Y-%m-%d')
        cur.execute("SELECT COUNT(*) FROM requests WHERE terminal_id = %s AND DATE(timestamp) = %s", (mess, today_date))
        existing_entries_count = cur.fetchone()[0]

        if existing_entries_count == 0:
            markup = types.InlineKeyboardMarkup()
            markup.add(types.InlineKeyboardButton('Не работает снятие.', callback_data='cash_out'))
            markup.add(types.InlineKeyboardButton('Не работает пополнение.', callback_data='cash_in'))
            markup.add(types.InlineKeyboardButton('Устройство не в сервисе.', callback_data='out_service'))
            markup.add(types.InlineKeyboardButton('Устройство выключено.', callback_data='offline'))
            markup.add(types.InlineKeyboardButton('Устройство зависло.', callback_data='stuck'))

            bot.reply_to(message, f'Прошу выбрать тип сбоя для отправки заявки', reply_markup=markup)
        else:
            bot.reply_to(message, f'Заявка по данному терминалу {mess} уже существует. Инцидент в работе!')
    else:
        bot.reply_to(message, f'Не верное ID терминала, попробуйте снова')

    cur.close()

    # Обновить запись идентификатора пользователя в словаре при вводе нового идентификатора
    user_requests[message.chat.id] = {'id': mess, 'processed': False}

# Функция для сохранения запроса в БД
def save_request_to_db(terminal_id, failure_type, callback):
    cur = conn.cursor()

    # Проверяем, существует ли уже запись с таким же terminal_id и сегодняшней датой
    today_date = date.today().strftime('%Y-%m-%d')
    cur.execute("SELECT COUNT(*) FROM requests WHERE terminal_id = %s AND DATE(timestamp) = %s", (terminal_id, today_date))
    existing_entries_count = cur.fetchone()[0]

    if existing_entries_count == 0:
        # Если на сегодня нет записи, сохраняем запрос в БД
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        cur.execute("INSERT INTO requests (terminal_id, failure_type, timestamp) VALUES (%s, %s, %s)",
                    (terminal_id, failure_type, timestamp))
        conn.commit()
        bot.send_message(callback.message.chat.id, f'Запрос на идентификатор терминала {terminal_id} успешно сохранен на сегодня.')
    else:
        # Если запись уже существует на сегодня, уведомить пользователя, что она не будет сохранена снова
        bot.send_message(callback.message.chat.id, f'Запрос на идентификатор терминала {terminal_id} уже сохранен на сегодня.')
        
    cur.close()

# Действия при нажатии кнопки
@bot.callback_query_handler(func=lambda callback: True)
def callback_message(callback):
    if callback.data in ['cash_out', 'cash_in', 'out_service', 'offline', 'stuck']:
        bot.send_message(callback.message.chat.id, f'Заявка по данному (ID {mess} Тип: {callback.data}) отправлена!')
        save_request_to_db(terminal_id=mess, failure_type=callback.data, callback=callback)

        # Устанавливаем запрос пользователя как обработанный, когда он нажимает кнопку
        user_requests[callback.message.chat.id]['processed'] = True
    else:
        bot.send_message(callback.message.chat.id, f'Ошибка!')

# Функция работает онлайн
bot.infinity_polling()


conn.close()

